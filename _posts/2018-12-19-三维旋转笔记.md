---
layout: post
title: 3D Notes
---
# 三维旋转笔记

## 1. 旋转矩阵`$\mathbf{R}$`
### 1.1. 二维旋转矩阵
区分静态坐标系下 **向量的旋转** 和 动态坐标自身的旋转，以二维为例，逆时针旋转`$\theta$`。
- 对于前者，向量本身旋转，推导过程利用和角公式`$\cos(a+b)=\cos a\cos b - \sin a\sin b$`等。具体而言，假定原向量`$v1$` 坐标为 `$(x_1,y_1)$`，逆时针旋转`$\theta$`后为
`$v_2=(x_2,y_2)$`，且`$\|v_1\| = \|v_2\|$`，故`$x_2 = \|v_2\|\cos(\theta+\arctan(y_1/x_1))$`，
`$ x_2 = \|v_1\| \cos(\arctan(y_1/x_1))\cos\theta - \|v_1\| \sin(\arctan(y_1/x_1))\sin\theta$`，
`$ x_2= x_1\cos\theta - y_1\sin\theta$`。
同理`$y_2$`，故旋转矩阵总结如下：
```math
\mathbf{R} = \left[ 
\begin{matrix}
\cos\theta & -\sin\theta \\
\sin\theta & \cos\theta  
\end{matrix}
\right ]
```
- 对于后者，坐标轴本身逆时针旋转`$\theta$`，向量保持不变。
对应的旋转矩阵恰好是上述旋转矩阵的转置（也是逆），可以看作是向量顺时针旋转，即旋转角为`$-\theta$`，替换`$\sin$`项（或直接作图推导关系[link](https://www.cnblogs.com/meteoric_cry/p/7987548.html)）即可得：
```math
\mathbf{R'} = \left[ 
\begin{matrix}
\cos\theta & \sin\theta \\
-\sin\theta & \cos\theta  
\end{matrix}
\right ]
```

### 1.2. 三维旋转矩阵
- 考虑变换坐标（相当于坐标轴旋转），以下为普适公式
```math
[\mathbf{e'_1},\mathbf{e'_2},\mathbf{e'_3}] \left[ 
\begin{matrix}
x' \\
y' \\
z'  
\end{matrix}
\right ] = 
[\mathbf{e_1},\mathbf{e_2},\mathbf{e_3}] \left[ 
\begin{matrix}
x \\
y \\
z  
\end{matrix}
\right ]=>

 \left[ 
\begin{matrix}
x' \\
y' \\
z'  
\end{matrix}
\right ] = 
\left[ 
\begin{matrix}
\mathbf{{e'}^T_1} \\
\mathbf{{e'}^T_2} \\
\mathbf{{e'}^T_3}  
\end{matrix}
\right ]
[\mathbf{e_1},\mathbf{e_2},\mathbf{e_3}] \left[ 
\begin{matrix}
x \\
y \\
z  
\end{matrix}
\right ]
=\left[ 
\begin{matrix}
\mathbf{{e'}^T_1}\mathbf{e_1} & \mathbf{{e'}^T_1}\mathbf{e_2} & \mathbf{{e'}^T_1}\mathbf{e_3}  \\
\mathbf{{e'}^T_2}\mathbf{e_1} & \mathbf{{e'}^T_2}\mathbf{e_2} & \mathbf{{e'}^T_2}\mathbf{e_3}\\
\mathbf{{e'}^T_3}\mathbf{e_1} & \mathbf{{e'}^T_3}\mathbf{e_2} & \mathbf{{e'}^T_3}\mathbf{e_3}  
\end{matrix}
\right ]
\left[ 
\begin{matrix}
x \\
y \\
z  
\end{matrix}
\right ] = \mathbf{R}\left[ 
\begin{matrix}
x \\
y \\
z  
\end{matrix}
\right ]
=>

\mathbf{R}=
\left[ 
\begin{matrix}
\mathbf{{e'}^T_1}\mathbf{e_1} & \mathbf{{e'}^T_1}\mathbf{e_2} & \mathbf{{e'}^T_1}\mathbf{e_3}  \\
\mathbf{{e'}^T_2}\mathbf{e_1} & \mathbf{{e'}^T_2}\mathbf{e_2} & \mathbf{{e'}^T_2}\mathbf{e_3}\\
\mathbf{{e'}^T_3}\mathbf{e_1} & \mathbf{{e'}^T_3}\mathbf{e_2} & \mathbf{{e'}^T_3}\mathbf{e_3}  
\end{matrix}
\right ]

```

- 连续多次动态旋转   
    **先`$\mathbf{R1}$`再`$\mathbf{R2}$`（`$\mathbf{R2}$`为相对于
    `$\mathbf{R1}$`后的坐标轴旋转）的连续动态旋转，坐标旋转矩阵应为 `$\mathbf{R2}\mathbf{R1}$`**

```math
\left[ 
\begin{matrix}
x'' \\
y'' \\
z''  
\end{matrix}
\right ] = 
\left[ 
\begin{matrix}
\mathbf{{e''}^T_1} \\
\mathbf{{e''}^T_2} \\
\mathbf{{e''}^T_3}  
\end{matrix}
\right ]
[\mathbf{e'_1},\mathbf{e'_2},\mathbf{e'_3}] \left[ 
\begin{matrix}
x' \\
y' \\
z'  
\end{matrix}
\right ] = 
\mathbf{R}_{2} \left[ 
\begin{matrix}
x' \\
y' \\
z'  
\end{matrix}
\right ]=
\mathbf{R} \left[ 
\begin{matrix}
x \\
y \\
z  
\end{matrix}
\right ]

\mathbf{R} = \left[ 
\begin{matrix}
\mathbf{{e''}^T_1} \\
\mathbf{{e''}^T_2} \\
\mathbf{{e''}^T_3}  
\end{matrix}
\right ] = 
\mathbf{R}_{2}
\left[ 
\begin{matrix}
\mathbf{{e'}^T_1} \\
\mathbf{{e'}^T_2} \\
\mathbf{{e'}^T_3}  
\end{matrix}
\right ]
= \mathbf{R}_{2}\mathbf{R}_{1}
```

### 1.3. Python 实现例子
```python
# 二维旋转，点不变，坐标逆时针旋转
    R=np.array([[ cos(x),  sin(x)],
                [-sin(x),  cos(x)]])
    v’ = Rv

def angle2matrix(angles):
    ''' get rotation matrix from three rotation angles(degree). right-handed.
    Args:
        angles: [3,]. x, y, z angles
        x: pitch. positive for looking down.
        y: yaw. positive for looking left. 
        z: roll. positive for tilting head right. 
    Returns:
        R: [3, 3]. rotation matrix.
    '''
    x, y, z = np.deg2rad(angles[0]), np.deg2rad(angles[1]), np.deg2rad(angles[2])
    # x
    Rx=np.array([[1,      0,       0],
                 [0, cos(x),  -sin(x)],
                 [0, sin(x),   cos(x)]])
    # y
    # 注意，绕y轴逆时针转时，X轴需转270度才到Z轴，此矩阵与其他两个不同
    Ry=np.array([[ cos(y), 0, sin(y)],
                 [      0, 1,      0],
                 [-sin(y), 0, cos(y)]]) 
    # z
    Rz=np.array([[cos(z), -sin(z), 0],
                 [sin(z),  cos(z), 0],
                 [     0,       0, 1]])
    
    R=Rz.dot(Ry.dot(Rx))
    return R.astype(np.float32)
```

## 2. 欧拉角与万向锁
[参考资料](https://matthew-brett.github.io/transforms3d/gimbal_lock.html)
### 2.1. 欧拉角
欧拉角一般指的是动态坐标轴转动，必须指定转动的顺序。如先绕Z轴转动   `$\alpha$`，再绕新坐标轴下的Y轴转动`$\beta$`，最后再绕新坐标轴下的X轴转动`$\gamma$`.
即 `$Z \rightarrow Y \rightarrow  X$`。

**ChenLi 的做法便是如此(当然，还有别的方式)**

**注意以下表达欧拉角时，** `$[\alpha, \beta, \gamma]$` **依次对应旋转顺序 ZYX**

**以飞机为例**，机头朝外，为 X 轴， 向上为 Z 轴， 右侧机翼为 Y 轴，满足右手系。ZYX 对应的旋转为 先绕Z轴偏航（正方向为人的视角机头右偏），再绕 Y' 轴俯仰（正方向为低头），最后绕 X' 轴翻滚 （正方向为人的视角右侧机翼升高）。
**偏航yaw -> 俯仰pitch -> 翻滚roll**


输入 `$[\alpha, \beta, \gamma]$`，输出的旋转矩阵为 `$\mathbf{R}=\mathbf{R}_x(\gamma)
\mathbf{R}_y(\beta)\mathbf{R}_z(\alpha)$`。其中

```math
\mathbf{R}_x = \left[ 
\begin{matrix}
1 & 0 & 0 \\
0 & \cos\gamma & \sin\gamma \\
0 & -\sin\gamma & \cos\gamma  
\end{matrix}
\right ],

\mathbf{R}_y = \left[ 
\begin{matrix}
\cos\beta & 0 & -\sin\beta \\
0 & 1 & 0 \\
\sin\beta & 0 & \cos\beta  
\end{matrix}
\right ]

\mathbf{R}_z = \left[ 
\begin{matrix}
\cos\alpha & \sin\alpha & 0 \\
-\sin\alpha & \cos\alpha & 0 \\
0 & 0 & 1 
\end{matrix}
\right ]

```

```math
\mathbf{R}(\gamma,\beta,\alpha) = 
\mathbf{R}_x = \left[ 
\begin{matrix}
1 & 0 & 0 \\
0 & \cos\gamma & \sin\gamma \\
0 & -\sin\gamma & \cos\gamma  
\end{matrix}
\right ]
\left[ 
\begin{matrix}
\cos\beta & 0 & -\sin\beta \\
0 & 1 & 0 \\
\sin\beta & 0 & \cos\beta  
\end{matrix}
\right ]
\left[ 
\begin{matrix}
\cos\alpha & \sin\alpha & 0 \\
-\sin\alpha & \cos\alpha & 0 \\
0 & 0 & 1 
\end{matrix}
\right ]

=
\left[ 
\begin{matrix}
\cos\alpha \cos\beta & \sin\alpha \cos\beta & -\sin\beta \\
\cos\alpha\sin\beta\sin\gamma - \sin\alpha\cos\gamma & \sin\alpha\sin\beta\sin\gamma+\cos\alpha\cos\gamma & \cos\beta\sin\gamma \\
\cos\alpha\sin\beta\cos\gamma+\sin\alpha\sin\gamma & \sin\alpha\sin\beta\cos\gamma - 
\cos\alpha\sin\gamma & \cos\beta\cos\gamma
\end{matrix}
\right ]
```
**注意，与[参考资料](https://matthew-brett.github.io/transforms3d/gimbal_lock.html)有些许不同，本笔记为轴旋转Rz(a)Ry(b)Rz(c)，而参考资料中为物体旋转rx(a)ry(b)Rz(c)，二者变量名称顺序也相反，实际上r为R的转置，故计算总结果进行转置并调整变量的名称顺序，二者是一致的。**

### 2.2. 万向锁
#### 2.2.1. 数学理论推导

如果 `$\beta =\pm \frac{\pi}{2}$`，会产生万向锁，即最后绕X轴转动实际上的转轴和第一次旋转时的Z轴相同，丧失了一个自由度。以`$\beta = -\frac{\pi}{2}$` 为例（俯仰角抬头90°），则`$\sin\beta = -1, \cos\beta = 0$`，从数学推导上有

```math
\mathbf{R}(\gamma,\beta,\alpha) = 
\left[ 
\begin{matrix}
0 & 0 & 1 \\
-\cos\alpha\sin\gamma - \sin\alpha\cos\gamma & -\sin\alpha\sin\gamma+\cos\alpha\cos\gamma & 0 \\
-\cos\alpha\cos\gamma+\sin\alpha\sin\gamma & -\sin\alpha\cos\gamma - 
\cos\alpha\sin\gamma & 0
\end{matrix}
\right ]

=
\left[ 
\begin{matrix}
0 & 0 & 1 \\
-\sin(\alpha+\gamma) & \cos(\alpha+\gamma)  & 0 \\
-\cos(\alpha+\gamma) & -\sin(\alpha+\gamma) & 0
\end{matrix}
\right ]
```

所以，当第二次旋转（俯仰角）为正负90°时，第三次绕X轴旋转`$\gamma$` 和第一次绕Z轴旋转 `$\alpha$` 其实转轴相同，即新X轴与最初的Z轴时重合的，这样便损失了一个自由度。
从数学上看，欧拉角`$[\alpha, -\frac{\pi}{2}, \gamma]$` 和 `$[\alpha + \gamma, -\frac{\pi}{2}, 0]$`(绕 Z 转`$\alpha+\beta$`，再绕 Y' 转 `$-90^{\circ}$`，不再绕 X' 转动)，甚至和`$[\alpha - x, -\frac{\pi}{2}, \gamma + x]$` 是等价表述同一个旋转的。

**特别的， `$[x, -\frac{\pi}{2}, -x]$` 和 `$[0, -\frac{\pi}{2}, 0]$`（直接抬头90°）。**
具体而言，旋转矩阵将退化为
```math
\mathbf{R} = \left[\begin{matrix}
0 & 0 & 1 \\
0 & 1 & 0 \\
-1 & 0 & 0
\end{matrix}
\right ]
```
即用旧坐标系来表达，新坐标系 X 轴为 `$[0, 0, 1]^\text{T}$` ，Y轴 仍为 `$[0,1,0]^\text{T}$` ，Z轴 为 `$[-1,0,0]^\text{T}$`。（R为坐标轴旋转，故每行为新轴在旧坐标系下的方向）
。或者说原坐标系下有一个点 `$p =[1, 0, 0]^\text{T}$`，只旋转坐标轴，而不变动该点，
那么该点在新坐标系下的坐标即为 `$\mathbf{R}p$`，在这里具体则是 `$[0, 0, -1]^\text{T}$`
(按列看，第一列)。

由此可知，给定一个这样的旋转位置（`$\beta = \pm \frac{\pi}{2}$`），则求解欧拉角将是多解的。这就是万向锁现象。

#### 2.2.2 动画欧拉角插值问题
对于游戏中的动画制作，经常给定关键帧的欧拉角，关键帧之间的旋转情况根据相邻关键帧的欧拉角进行线性插值得到，之后再按照欧拉角转动模型，渲染出每一帧。

[参考blog](https://blog.csdn.net/fanglrui/article/details/8708386)

假定我们有以下关键帧
```math
 [Z, Y, X]

R_0: [0, 0, 0]

R_1: [90, 0, 0]

R_2: [90, -90, 0]

R_3: [0, 0, 90]
```
动画预想效果是 R0时刻飞机机头朝外，向右偏航90°，机头朝右，此时是时刻R1；

再抬头 90°，机头朝上，飞机腹部朝右，此时为时刻R2；

最后从右视图看，飞机逆时针旋转90度（其实是`$\mathbf{R}_z(-\frac{\pi}{2})$`），达到R3时刻的位置，此时机头朝外，飞机腹部朝右。（也就是说以上三次操作，等同于直接绕X翻滚90°）

求出从R0到R1，以及从R1到R2的插值，然后每帧进行相应的旋转，其结果是符合我们的预想的。
但是求出R2到R3的几个插值后，旋转的到的路径与期望不符，比如这两个插值
```math
[Z, Y, X]

[60, -60, 30]

[45, -45, 45]
```
做这两个旋转，可以发现与期望的路径发生偏移，即从R2到R3时，飞机以右偏的曲线完成机头由朝上变成朝外的东躲。

这就是《3D数学基础：图形与游戏开发》中提到的“路径偏移”和“摄像机抖动”。

总结：如果动画师在某个关键帧处指定了会引发万向锁的方位，则下一个关键帧的方位一旦超出了万向锁的约束范围，则这两个关键帧之间的路径就会发生偏移，反映在角色动画上是旋转偏移，反映在镜头控制上就是镜头抖动。


要获得路径偏移的感性认识，可以参考这个视频：这个视频和我的描述有些不同，该视频使用一个称为万向节的奇怪装置解释的，而我是直接用的物体坐标系但路径偏移都是一样的。

http://v.youku.com/v_show/id_XNzkyOTIyMTI=.html 



#### 2.2.3. 怎样解决万向锁问题？ 
**出现这个问题的根本原因是在万向锁情况下对欧拉角的插值不是线性的**，因此旋转路径发生偏移。

解决方法是：

**将欧拉角转换为四元数，对四元数进行slerp即球面线性插值**，再将这一系列四元数转换为对应的欧拉角，而后作用于角色。缺点是耗费一定的内存，但角色可以任意旋转，灵活度高。


## 3. 四元数
旋转矩阵用9个量描述3个自由度的旋转，具有冗余性；欧拉角和旋转向量是紧凑的，但是又奇异性。我们无法找到不带奇异性的三维向量描述方法。因此引入四元数，它既是紧凑的，也没有奇异性。

一个四元数`$\mathbf{q}$`拥有一个实部和三个虚部。我们将实不写在前面。
```math
\mathbf{q} = q_0 +q_1i+q_2j+q_3k,
```
其中`$i,j,k$`为四四元数的三个虚部。三个虚部满足下列关系：
```math
\left\{\begin{aligned}
&i^2 = j^2 =k^2 =-1 \\ 
&ij=k, ji=-k \\
&jk=i,kj=-i\\
&ki=j,ik=-j
\end{aligned}\right.
```
有时也可以用一个标量和一个向量来表达四元数：
```math
\mathbf{q} = \left[ s, \mathbf{v} \right], s=q_0\in \mathbb{R}, \mathbf{v}=[q_1,q_2,q_3]^\text{T} \in \mathbb{R}^3
```

### 3.1. 四元数运算
#### 3.1.1 乘法

```math
\mathbf{q_a}\mathbf{q_b} = [s_as_b-\mathbf{v}_a^\text{T}\mathbf{v}_b, 
s_a\mathbf{v}_b + s_b \mathbf{v}_a + \mathbf{v}_a\times \mathbf{v}_b]
```

#### 3.1.2. 共轭
```math
\mathbf{q}^* = \left[ s, -\mathbf{v} \right]

\mathbf{q}^*\mathbf{q} = \mathbf{q}\mathbf{q}^* = 
[s^2+\mathbf{v}^\text{T}\mathbf{v}, \mathbf{0}]
```

#### 3.1.3. 模长
```math
\|\mathbf{q}\| = \sqrt{s^2+x^2+y^2+z^2}

\|\mathbf{q}_a \mathbf{q}_b\|  =  \|\mathbf{q}_a\|\|\mathbf{q}_b\|
```

#### 3.1.4. 逆
```math
\mathbf{q}^{-1} = \frac{\mathbf{q}^*}{\|\mathbf{q}\|^2}

\mathbf{q}\mathbf{q}^{-1} = \mathbf{q}^{-1}\mathbf{q} = \mathbf{1}

(\mathbf{q}_a\mathbf{q}_b)^{-1}=
\mathbf{q}_b^{-1}\mathbf{q}_a^{-1}
```
#### 3.1.5. 数乘与点乘
与向量一致
```math
k\mathbf{q} = [ks, k\mathbf{v}]

\mathbf{q}_a \cdot \mathbf{q}_b = s_as_b + x_ax_b + y_ay_b + z_az_b
```

### 3.2. 用四元数表示旋转
假设一个空间三维点 `$\mathbf{p}=[x,y,z] \in \mathbb{R}^3$`，以及一个又轴角 `$\mathbf{n},\theta$` 制定的旋转。三维点`$\mathbf{p}$`旋转之后变为`$\mathbf{p}'$`。

首先将三维点用一个虚四元数表示
```math
\mathbf{p} = [0, x, y, z] = [0, \mathbf{v}].
```

四元数表示旋转
```math
\mathbf{q} = [\cos \frac{\theta}{2}, \mathbf{n} \sin \frac{\theta}{2}].
```
那么，旋转后的点`$\mathbf{p}'$`即可表示为这样的乘积：

```math
\mathbf{p}' = \mathbf{q}\mathbf{p}\mathbf{q}^{-1}.
```
计算结果的实部为0，其虚部的三个量表示旋转后3D点的坐标。




### 3.3. 四元数与旋转向量的转换
- 从旋转向量到四元数
```math
\mathbf{q} = \left[\cos\frac{\theta}{2}, n_x\sin\frac{\theta}{2}, n_y\sin\frac{\theta}{2}, n_z\sin\frac{\theta}{2}\right]^{\text{T}}
```

- 从四元数到旋转向量
```math
\left\{\begin{aligned}
&\theta = 2\arccos q_0\\ 
&[n_x,n_y,n_z]^{\text{T}} =[q_1,q_2,q_3]^{\text{T}} / \sin\frac{\theta}{2}
\end{aligned}\right.
```
注意，对`$\theta$` 加上 `$2\pi$`会得到一个相同的旋转，但是四元数变成 `$-\mathbf{q}$`.因此，在四元数中，任意的旋转都可以由两个互为相反数的四元数表示。

### 3.4. 四元数与旋转矩阵的转换
- 从四元数到旋转矩阵           
    可以先将四元数转为旋转向量，再根据罗德里格斯公司转化为旋转矩阵，但是这样需要计算一个`$\arccos$`函数，代价较大。以下给出一种转换方式

```math
\mathbf{R} = \begin{bmatrix}
 1-2q_2^2-2q_3^2 & 2q_1q_2-2q_0q_3 & 2q_1q_3+2q_0q_2 \\ 
 2q_1q_2+2q_0q_3 & 1-2q_1^2-2q_3^2 & 2q_2q_3-2q_0q_1 \\ 
 2q_1q_3-2q_0q_2 & 2q_2q_3+2q_0q_1 & 1 - 2q_1^2-2q_2^2
\end{bmatrix}
```
- 从旋转矩阵到四元数

```math
q_0=\frac{\sqrt{\text{tr}(\mathbf{R})+1}}{2},
q_1=\frac{m_{23} -m_{32}}{4q_0},q_1=\frac{m_{31}-m_{13}}{4q_0},q_1=\frac{m_{12}-m_{21}}{4q_0}
```
注意，由于`$\mathbf{q}$`和`$-\mathbf{q}$`表示同一个旋转，所以一个`$\mathbf{R}$`对应的四元数非唯一。因此，除上述转换方法之外，还存在其他集中计算方法。尤其是当`$q_0$`较小时，其余3个分量会非常大，导致解不稳定，此时我们再考虑其他方式进行转换。

## 4. 旋转向量与旋转矩阵的关系
旋转轴为`$\mathbf{n}$`,角度为`$\theta$`的旋转，对应的旋转向量为`$\theta \mathbf{n}$`.

- 从旋转向量到旋转矩阵  
    旋转向量`$\theta\mathbf{n}$`与旋转矩阵`$\mathbf{R}$`满足罗德里格公式。

```math
\mathbf{R} = \cos \theta \mathbf{I}
+(1-\cos \theta)\mathbf{n}\mathbf{n}^\text{T} + \sin \theta \mathbf{n}^{\wedge}

\mathbf{n}^{\wedge} = \left[ 
\begin{matrix}
0 & -n_3 & n_2 \\
n_3 & 0 & -n_1 \\
-n_2 & n_1 & 0 
\end{matrix}
\right ]
```

- 从旋转矩阵到旋转向量  
    转轴`$\mathbf{n}$`是旋转矩阵`$\mathbf{R}$`特征值1对应的特征向量。   
    求解此方程，再归一化，就得到了旋转轴。
```math
\text{tr}(\mathbf{R}) = 3\cos\theta 
+ (1 - \cos \theta) + 0
= 1 + 2\cos \theta

\theta = \arccos(\frac{\text{tr}(\mathbf{R})-1}{2})

\mathbf{R}\mathbf{n} = \mathbf{R}
```
